# -*- coding: utf-8 -*-
"""app_recommendation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1E828HNrXeLX1lwqZU2BnC6fW0M5MS9tN
"""

# app_recommendation.py

import streamlit as st
import pandas as pd
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.decomposition import TruncatedSVD

# 1. 데이터 불러오기
@st.cache_data
def load_data():
    try:
        df = pd.read_csv("0604ai_apps_reviews_combined .csv", encoding='utf-8')
    except:
        df = pd.read_csv("0604ai_apps_reviews_combined .csv", encoding='cp949')
    df['app_name'] = df['app_name'].str.replace('\n', ' ', regex=False)
    return df

rating_data = load_data()

# 2. 필터링 및 앱 인덱스 생성
app_counts = rating_data['app_name'].value_counts()
popular_apps = app_counts[app_counts >= 100].index
filtered_df = rating_data[rating_data['app_name'].isin(popular_apps)].copy()
filtered_df['app_index'] = filtered_df['app_name'].astype('category').cat.codes
filtered_app_list = filtered_df[['app_name', 'app_index']].drop_duplicates().sort_values('app_index').reset_index(drop=True)

# 3. 협업 필터링 (SVD)
pivot = filtered_df.pivot(index='app_name', columns='reviewId', values='score').fillna(0)
svd_model = TruncatedSVD(n_components=12, random_state=42)
svd_matrix = svd_model.fit_transform(pivot)
svd_sim = cosine_similarity(svd_matrix)

# 4. 콘텐츠 기반 (TF-IDF)
tfidf = TfidfVectorizer(max_features=1000)
tfidf_matrix = tfidf.fit_transform(filtered_df['content'].fillna(''))

app_vectors = []
for app_idx in filtered_app_list['app_index']:
    indices = (filtered_df['app_index'] == app_idx).values
    app_review_vectors = tfidf_matrix[indices]
    app_mean_vector = app_review_vectors.mean(axis=0)
    app_vectors.append(np.asarray(app_mean_vector).flatten())

app_matrix = np.vstack(app_vectors)
content_sim = cosine_similarity(app_matrix)

# 5. 하이브리드 유사도
alpha = 0.5
hybrid_sim = alpha * svd_sim + (1 - alpha) * content_sim

# 6. 앱 설명 데이터 불러오기
@st.cache_data
def load_app_descriptions():
    return filtered_df.groupby('app_name')['content'].first().reset_index()

app_descriptions = load_app_descriptions()

# 7. 추천 함수
def get_recommendations_by_app(app_name, sim_matrix, app_list, top_n=5):
    try:
        app_id = app_list[app_list['app_name'] == app_name]['app_index'].values[0]
    except IndexError:
        return ["❌ 앱을 찾을 수 없습니다."]
    sim_scores = list(enumerate(sim_matrix[app_id]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)[1:top_n+1]
    recommended_ids = [i[0] for i in sim_scores]
    recommended_apps = app_list[app_list['app_index'].isin(recommended_ids)]['app_name'].values
    return recommended_apps

def get_recommendations_by_purpose(user_input, app_descriptions, top_n=5):
    tfidf = TfidfVectorizer()
    doc_vecs = tfidf.fit_transform(app_descriptions['content'].fillna(''))
    user_vec = tfidf.transform([user_input])
    cosine_sim = cosine_similarity(user_vec, doc_vecs).flatten()
    top_indices = cosine_sim.argsort()[::-1][:top_n]
    return app_descriptions['app_name'].iloc[top_indices].tolist()

# 8. Streamlit UI
st.title("📱 AI 앱 추천 시스템")
st.write("사용 목적이나 이전에 사용한 앱 이름을 입력하면 관련 앱을 추천해드려요!")

option = st.radio("추천 방법을 선택하세요:", ["사용 목적 기반 추천", "기존 사용 앱 기반 추천"])

if option == "기존 사용 앱 기반 추천":
    selected_app = st.selectbox("기존에 사용한 앱을 선택하세요:", filtered_app_list['app_name'].tolist())
    if st.button("추천받기"):
        recommendations = get_recommendations_by_app(selected_app, hybrid_sim, filtered_app_list)
        st.subheader("📌 추천 앱 목록:")
        for i, app in enumerate(recommendations, 1):
            st.write(f"{i}. {app}")

elif option == "사용 목적 기반 추천":
    user_input = st.text_input("어떤 용도로 앱을 찾고 계신가요?")
    if st.button("추천받기"):
        if user_input.strip():
            recommendations = get_recommendations_by_purpose(user_input, app_descriptions)
            st.subheader("📌 추천 앱 목록:")
            for i, app in enumerate(recommendations, 1):
                st.write(f"{i}. {app}")
        else:
            st.warning("사용 목적을 입력해주세요.")