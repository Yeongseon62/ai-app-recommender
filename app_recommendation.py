# -*- coding: utf-8 -*-
"""app_recommendation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1E828HNrXeLX1lwqZU2BnC6fW0M5MS9tN
"""

# app_recommendation.py

import streamlit as st
import pandas as pd
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.decomposition import TruncatedSVD

# 1. ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸°
@st.cache_data
def load_data():
    try:
        df = pd.read_csv("0604ai_apps_reviews_combined .csv", encoding='utf-8')
    except:
        df = pd.read_csv("0604ai_apps_reviews_combined .csv", encoding='cp949')
    df['app_name'] = df['app_name'].str.replace('\n', ' ', regex=False)
    return df

rating_data = load_data()

# 2. í•„í„°ë§ ë° ì•± ì¸ë±ìŠ¤ ìƒì„±
app_counts = rating_data['app_name'].value_counts()
popular_apps = app_counts[app_counts >= 100].index
filtered_df = rating_data[rating_data['app_name'].isin(popular_apps)].copy()
filtered_df['app_index'] = filtered_df['app_name'].astype('category').cat.codes
filtered_app_list = filtered_df[['app_name', 'app_index']].drop_duplicates().sort_values('app_index').reset_index(drop=True)

# 3. í˜‘ì—… í•„í„°ë§ (SVD)
pivot = filtered_df.pivot(index='app_name', columns='reviewId', values='score').fillna(0)
svd_model = TruncatedSVD(n_components=12, random_state=42)
svd_matrix = svd_model.fit_transform(pivot)
svd_sim = cosine_similarity(svd_matrix)

# 4. ì½˜í…ì¸  ê¸°ë°˜ (TF-IDF)
tfidf = TfidfVectorizer(max_features=1000)
tfidf_matrix = tfidf.fit_transform(filtered_df['content'].fillna(''))

app_vectors = []
for app_idx in filtered_app_list['app_index']:
    indices = (filtered_df['app_index'] == app_idx).values
    app_review_vectors = tfidf_matrix[indices]
    app_mean_vector = app_review_vectors.mean(axis=0)
    app_vectors.append(np.asarray(app_mean_vector).flatten())

app_matrix = np.vstack(app_vectors)
content_sim = cosine_similarity(app_matrix)

# 5. í•˜ì´ë¸Œë¦¬ë“œ ìœ ì‚¬ë„
alpha = 0.5
hybrid_sim = alpha * svd_sim + (1 - alpha) * content_sim

# 6. ì•± ì„¤ëª… ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸°
@st.cache_data
def load_app_descriptions():
    return filtered_df.groupby('app_name')['content'].first().reset_index()

app_descriptions = load_app_descriptions()

# 7. ì¶”ì²œ í•¨ìˆ˜
def get_recommendations_by_app(app_name, sim_matrix, app_list, top_n=5):
    try:
        app_id = app_list[app_list['app_name'] == app_name]['app_index'].values[0]
    except IndexError:
        return ["âŒ ì•±ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."]
    sim_scores = list(enumerate(sim_matrix[app_id]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)[1:top_n+1]
    recommended_ids = [i[0] for i in sim_scores]
    recommended_apps = app_list[app_list['app_index'].isin(recommended_ids)]['app_name'].values
    return recommended_apps

def get_recommendations_by_purpose(user_input, app_descriptions, top_n=5):
    tfidf = TfidfVectorizer()
    doc_vecs = tfidf.fit_transform(app_descriptions['content'].fillna(''))
    user_vec = tfidf.transform([user_input])
    cosine_sim = cosine_similarity(user_vec, doc_vecs).flatten()
    top_indices = cosine_sim.argsort()[::-1][:top_n]
    return app_descriptions['app_name'].iloc[top_indices].tolist()

# 8. Streamlit UI
st.title("ğŸ“± AI ì•± ì¶”ì²œ ì‹œìŠ¤í…œ")
st.write("ì‚¬ìš© ëª©ì ì´ë‚˜ ì´ì „ì— ì‚¬ìš©í•œ ì•± ì´ë¦„ì„ ì…ë ¥í•˜ë©´ ê´€ë ¨ ì•±ì„ ì¶”ì²œí•´ë“œë ¤ìš”!")

option = st.radio("ì¶”ì²œ ë°©ë²•ì„ ì„ íƒí•˜ì„¸ìš”:", ["ì‚¬ìš© ëª©ì  ê¸°ë°˜ ì¶”ì²œ", "ê¸°ì¡´ ì‚¬ìš© ì•± ê¸°ë°˜ ì¶”ì²œ"])

if option == "ê¸°ì¡´ ì‚¬ìš© ì•± ê¸°ë°˜ ì¶”ì²œ":
    selected_app = st.selectbox("ê¸°ì¡´ì— ì‚¬ìš©í•œ ì•±ì„ ì„ íƒí•˜ì„¸ìš”:", filtered_app_list['app_name'].tolist())
    if st.button("ì¶”ì²œë°›ê¸°"):
        recommendations = get_recommendations_by_app(selected_app, hybrid_sim, filtered_app_list)
        st.subheader("ğŸ“Œ ì¶”ì²œ ì•± ëª©ë¡:")
        for i, app in enumerate(recommendations, 1):
            st.write(f"{i}. {app}")

elif option == "ì‚¬ìš© ëª©ì  ê¸°ë°˜ ì¶”ì²œ":
    user_input = st.text_input("ì–´ë–¤ ìš©ë„ë¡œ ì•±ì„ ì°¾ê³  ê³„ì‹ ê°€ìš”?")
    if st.button("ì¶”ì²œë°›ê¸°"):
        if user_input.strip():
            recommendations = get_recommendations_by_purpose(user_input, app_descriptions)
            st.subheader("ğŸ“Œ ì¶”ì²œ ì•± ëª©ë¡:")
            for i, app in enumerate(recommendations, 1):
                st.write(f"{i}. {app}")
        else:
            st.warning("ì‚¬ìš© ëª©ì ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.")