# -*- coding: utf-8 -*-
"""app_recommendation(1).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uAqM3JTvVS2HxoYAEOUrqLIuPln8QpBd
"""

# app_recommendation.py (최종 수정본)

import streamlit as st
import pandas as pd
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.decomposition import TruncatedSVD

# 1. 데이터 불러오기
@st.cache_data
def load_data():
    try:
        # --- 수정: 파일 이름 끝의 공백 제거 ---
        df = pd.read_csv("0604ai_apps_reviews_combined.csv", encoding='utf-8')
    except FileNotFoundError:
        st.error("'0604ai_apps_reviews_combined.csv' 파일을 찾을 수 없습니다. Colab에 파일을 업로드했는지 확인해주세요.")
        return None
    except Exception:
        df = pd.read_csv("0604ai_apps_reviews_combined.csv", encoding='cp949')

    if df is not None:
        df['app_name'] = df['app_name'].str.replace('\n', ' ', regex=False)
    return df

rating_data = load_data()

# --- 데이터 로딩 실패 시 앱 실행을 중단하도록 수정 ---
if rating_data is None:
    st.stop()

# 2. 필터링 및 앱 인덱스 생성
app_counts = rating_data['app_name'].value_counts()
popular_apps = app_counts[app_counts >= 100].index
filtered_df = rating_data[rating_data['app_name'].isin(popular_apps)].copy()
filtered_df['app_index'] = filtered_df['app_name'].astype('category').cat.codes
filtered_app_list = filtered_df[['app_name', 'app_index']].drop_duplicates().sort_values('app_index').reset_index(drop=True)

# --- 수정: 앱 상세정보 DataFrame 생성 (app_description 컬럼이 있다고 가정) ---
# 만약 실제 설명 컬럼이 'content'라면 'app_description'을 'content'로 변경하세요.
try:
    app_details = filtered_df[['app_name', 'app_description']].drop_duplicates('app_name').reset_index(drop=True)
except KeyError:
    st.error("DataFrame에 'app_description' 컬럼이 없습니다. 컬럼명을 확인해주세요. 리뷰 내용('content')을 대신 사용하려면 코드를 수정해야 합니다.")
    st.stop()


# 3. 협업 필터링 (SVD)
pivot = filtered_df.pivot(index='app_name', columns='reviewId', values='score').fillna(0)
svd_model = TruncatedSVD(n_components=12, random_state=42)
svd_matrix = svd_model.fit_transform(pivot)
svd_sim = cosine_similarity(svd_matrix)

# 4. 콘텐츠 기반 (TF-IDF) - 리뷰 기반 유사도
tfidf_reviews = TfidfVectorizer(max_features=1000)
tfidf_matrix_reviews = tfidf_reviews.fit_transform(filtered_df['content'].fillna(''))

app_vectors = []
for app_idx in filtered_app_list['app_index']:
    indices = (filtered_df['app_index'] == app_idx).values
    app_review_vectors = tfidf_matrix_reviews[indices]
    app_mean_vector = app_review_vectors.mean(axis=0)
    app_vectors.append(np.asarray(app_mean_vector).flatten())

app_matrix = np.vstack(app_vectors)
content_sim = cosine_similarity(app_matrix)

# 5. 하이브리드 유사도
alpha = 0.5
hybrid_sim = alpha * svd_sim + (1 - alpha) * content_sim

# 6. 추천 함수
# --- 수정: 함수 이름 변경 및 details_df 파라미터 추가 ---
def get_recommendations_by_app(app_name, sim_matrix, app_list, details_df, top_n=5):
    try:
        app_id = app_list[app_list['app_name'] == app_name]['app_index'].values[0]
    except IndexError:
        return pd.DataFrame() # 앱을 못 찾으면 빈 DataFrame 반환

    sim_scores = list(enumerate(sim_matrix[app_id]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)[1:top_n+1]
    recommended_ids = [i[0] for i in sim_scores]

    recommended_app_names = app_list[app_list['app_index'].isin(recommended_ids)]['app_name']

    return details_df[details_df['app_name'].isin(recommended_app_names)]

# --- 누락되었던 'get_recommendations_by_purpose' 함수 다시 추가 및 수정 ---
def get_recommendations_by_purpose(user_input, details_df, top_n=5):
    tfidf_desc = TfidfVectorizer()
    # 'app_description' 컬럼으로 유사도 계산
    doc_vecs = tfidf_desc.fit_transform(details_df['app_description'].fillna(''))
    user_vec = tfidf_desc.transform([user_input])

    cosine_sim = cosine_similarity(user_vec, doc_vecs).flatten()
    top_indices = cosine_sim.argsort()[::-1][:top_n]

    return details_df.iloc[top_indices]


# 7. Streamlit UI
st.title("📱 AI 앱 추천 시스템")
st.write("사용 목적이나 이전에 사용한 앱 이름을 입력하면 관련 앱을 추천해드려요!")

option = st.radio("추천 방법을 선택하세요:", ["기존 사용 앱 기반 추천", "사용 목적 기반 추천"])

# --- 수정: 원래의 if/elif UI 구조 복원 ---
if option == "기존 사용 앱 기반 추천":
    # --- 누락되었던 selectbox 다시 추가 ---
    selected_app = st.selectbox("기존에 사용한 앱을 선택하세요:", filtered_app_list['app_name'].tolist())

    if st.button("앱 기반 추천받기"):
        recommendations_df = get_recommendations_by_app(selected_app, hybrid_sim, filtered_app_list, app_details)
        st.subheader("📌 추천 앱 목록:")
        if not recommendations_df.empty:
            for index, row in recommendations_df.iterrows():
                st.subheader(f"✅ {row['app_name']}")
                st.write(row['app_description'])
                st.divider()
        else:
            st.warning("추천 앱을 찾을 수 없습니다.")

elif option == "사용 목적 기반 추천":
    # --- 누락되었던 text_input 다시 추가 ---
    user_input = st.text_input("어떤 용도로 앱을 찾고 계신가요? (예: 사진 편집, 영어 공부)")

    if st.button("목적 기반 추천받기"):
        if user_input.strip():
            recommendations_df = get_recommendations_by_purpose(user_input, app_details)
            st.subheader("📌 추천 앱 목록:")
            if not recommendations_df.empty:
                for index, row in recommendations_df.iterrows():
                    st.subheader(f"✅ {row['app_name']}")
                    st.write(row['app_description'])
                    st.divider()
            else:
                st.warning("추천 앱을 찾을 수 없습니다.")
        else:
            st.warning("사용 목적을 입력해주세요.")