# -*- coding: utf-8 -*-
"""app_recommendation(1).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uAqM3JTvVS2HxoYAEOUrqLIuPln8QpBd
"""

# app_recommendation.py (ìµœì¢… ìˆ˜ì •ë³¸)

import streamlit as st
import pandas as pd
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.decomposition import TruncatedSVD

# 1. ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸°
@st.cache_data
def load_data():
    try:
        # --- ìˆ˜ì •: íŒŒì¼ ì´ë¦„ ëì˜ ê³µë°± ì œê±° ---
        df = pd.read_csv("0604ai_apps_reviews_combined.csv", encoding='utf-8')
    except FileNotFoundError:
        st.error("'0604ai_apps_reviews_combined.csv' íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. Colabì— íŒŒì¼ì„ ì—…ë¡œë“œí–ˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.")
        return None
    except Exception:
        df = pd.read_csv("0604ai_apps_reviews_combined.csv", encoding='cp949')

    if df is not None:
        df['app_name'] = df['app_name'].str.replace('\n', ' ', regex=False)
    return df

rating_data = load_data()

# --- ë°ì´í„° ë¡œë”© ì‹¤íŒ¨ ì‹œ ì•± ì‹¤í–‰ì„ ì¤‘ë‹¨í•˜ë„ë¡ ìˆ˜ì • ---
if rating_data is None:
    st.stop()

# 2. í•„í„°ë§ ë° ì•± ì¸ë±ìŠ¤ ìƒì„±
app_counts = rating_data['app_name'].value_counts()
popular_apps = app_counts[app_counts >= 100].index
filtered_df = rating_data[rating_data['app_name'].isin(popular_apps)].copy()
filtered_df['app_index'] = filtered_df['app_name'].astype('category').cat.codes
filtered_app_list = filtered_df[['app_name', 'app_index']].drop_duplicates().sort_values('app_index').reset_index(drop=True)

# --- ìˆ˜ì •: ì•± ìƒì„¸ì •ë³´ DataFrame ìƒì„± (app_description ì»¬ëŸ¼ì´ ìˆë‹¤ê³  ê°€ì •) ---
# ë§Œì•½ ì‹¤ì œ ì„¤ëª… ì»¬ëŸ¼ì´ 'content'ë¼ë©´ 'app_description'ì„ 'content'ë¡œ ë³€ê²½í•˜ì„¸ìš”.
try:
    app_details = filtered_df[['app_name', 'app_description']].drop_duplicates('app_name').reset_index(drop=True)
except KeyError:
    st.error("DataFrameì— 'app_description' ì»¬ëŸ¼ì´ ì—†ìŠµë‹ˆë‹¤. ì»¬ëŸ¼ëª…ì„ í™•ì¸í•´ì£¼ì„¸ìš”. ë¦¬ë·° ë‚´ìš©('content')ì„ ëŒ€ì‹  ì‚¬ìš©í•˜ë ¤ë©´ ì½”ë“œë¥¼ ìˆ˜ì •í•´ì•¼ í•©ë‹ˆë‹¤.")
    st.stop()


# 3. í˜‘ì—… í•„í„°ë§ (SVD)
pivot = filtered_df.pivot(index='app_name', columns='reviewId', values='score').fillna(0)
svd_model = TruncatedSVD(n_components=12, random_state=42)
svd_matrix = svd_model.fit_transform(pivot)
svd_sim = cosine_similarity(svd_matrix)

# 4. ì½˜í…ì¸  ê¸°ë°˜ (TF-IDF) - ë¦¬ë·° ê¸°ë°˜ ìœ ì‚¬ë„
tfidf_reviews = TfidfVectorizer(max_features=1000)
tfidf_matrix_reviews = tfidf_reviews.fit_transform(filtered_df['content'].fillna(''))

app_vectors = []
for app_idx in filtered_app_list['app_index']:
    indices = (filtered_df['app_index'] == app_idx).values
    app_review_vectors = tfidf_matrix_reviews[indices]
    app_mean_vector = app_review_vectors.mean(axis=0)
    app_vectors.append(np.asarray(app_mean_vector).flatten())

app_matrix = np.vstack(app_vectors)
content_sim = cosine_similarity(app_matrix)

# 5. í•˜ì´ë¸Œë¦¬ë“œ ìœ ì‚¬ë„
alpha = 0.5
hybrid_sim = alpha * svd_sim + (1 - alpha) * content_sim

# 6. ì¶”ì²œ í•¨ìˆ˜
# --- ìˆ˜ì •: í•¨ìˆ˜ ì´ë¦„ ë³€ê²½ ë° details_df íŒŒë¼ë¯¸í„° ì¶”ê°€ ---
def get_recommendations_by_app(app_name, sim_matrix, app_list, details_df, top_n=5):
    try:
        app_id = app_list[app_list['app_name'] == app_name]['app_index'].values[0]
    except IndexError:
        return pd.DataFrame() # ì•±ì„ ëª» ì°¾ìœ¼ë©´ ë¹ˆ DataFrame ë°˜í™˜

    sim_scores = list(enumerate(sim_matrix[app_id]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)[1:top_n+1]
    recommended_ids = [i[0] for i in sim_scores]

    recommended_app_names = app_list[app_list['app_index'].isin(recommended_ids)]['app_name']

    return details_df[details_df['app_name'].isin(recommended_app_names)]

# --- ëˆ„ë½ë˜ì—ˆë˜ 'get_recommendations_by_purpose' í•¨ìˆ˜ ë‹¤ì‹œ ì¶”ê°€ ë° ìˆ˜ì • ---
def get_recommendations_by_purpose(user_input, details_df, top_n=5):
    tfidf_desc = TfidfVectorizer()
    # 'app_description' ì»¬ëŸ¼ìœ¼ë¡œ ìœ ì‚¬ë„ ê³„ì‚°
    doc_vecs = tfidf_desc.fit_transform(details_df['app_description'].fillna(''))
    user_vec = tfidf_desc.transform([user_input])

    cosine_sim = cosine_similarity(user_vec, doc_vecs).flatten()
    top_indices = cosine_sim.argsort()[::-1][:top_n]

    return details_df.iloc[top_indices]


# 7. Streamlit UI
st.title("ğŸ“± AI ì•± ì¶”ì²œ ì‹œìŠ¤í…œ")
st.write("ì‚¬ìš© ëª©ì ì´ë‚˜ ì´ì „ì— ì‚¬ìš©í•œ ì•± ì´ë¦„ì„ ì…ë ¥í•˜ë©´ ê´€ë ¨ ì•±ì„ ì¶”ì²œí•´ë“œë ¤ìš”!")

option = st.radio("ì¶”ì²œ ë°©ë²•ì„ ì„ íƒí•˜ì„¸ìš”:", ["ê¸°ì¡´ ì‚¬ìš© ì•± ê¸°ë°˜ ì¶”ì²œ", "ì‚¬ìš© ëª©ì  ê¸°ë°˜ ì¶”ì²œ"])

# --- ìˆ˜ì •: ì›ë˜ì˜ if/elif UI êµ¬ì¡° ë³µì› ---
if option == "ê¸°ì¡´ ì‚¬ìš© ì•± ê¸°ë°˜ ì¶”ì²œ":
    # --- ëˆ„ë½ë˜ì—ˆë˜ selectbox ë‹¤ì‹œ ì¶”ê°€ ---
    selected_app = st.selectbox("ê¸°ì¡´ì— ì‚¬ìš©í•œ ì•±ì„ ì„ íƒí•˜ì„¸ìš”:", filtered_app_list['app_name'].tolist())

    if st.button("ì•± ê¸°ë°˜ ì¶”ì²œë°›ê¸°"):
        recommendations_df = get_recommendations_by_app(selected_app, hybrid_sim, filtered_app_list, app_details)
        st.subheader("ğŸ“Œ ì¶”ì²œ ì•± ëª©ë¡:")
        if not recommendations_df.empty:
            for index, row in recommendations_df.iterrows():
                st.subheader(f"âœ… {row['app_name']}")
                st.write(row['app_description'])
                st.divider()
        else:
            st.warning("ì¶”ì²œ ì•±ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

elif option == "ì‚¬ìš© ëª©ì  ê¸°ë°˜ ì¶”ì²œ":
    # --- ëˆ„ë½ë˜ì—ˆë˜ text_input ë‹¤ì‹œ ì¶”ê°€ ---
    user_input = st.text_input("ì–´ë–¤ ìš©ë„ë¡œ ì•±ì„ ì°¾ê³  ê³„ì‹ ê°€ìš”? (ì˜ˆ: ì‚¬ì§„ í¸ì§‘, ì˜ì–´ ê³µë¶€)")

    if st.button("ëª©ì  ê¸°ë°˜ ì¶”ì²œë°›ê¸°"):
        if user_input.strip():
            recommendations_df = get_recommendations_by_purpose(user_input, app_details)
            st.subheader("ğŸ“Œ ì¶”ì²œ ì•± ëª©ë¡:")
            if not recommendations_df.empty:
                for index, row in recommendations_df.iterrows():
                    st.subheader(f"âœ… {row['app_name']}")
                    st.write(row['app_description'])
                    st.divider()
            else:
                st.warning("ì¶”ì²œ ì•±ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
        else:
            st.warning("ì‚¬ìš© ëª©ì ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.")